# HPGAPP - Authentication and User Profile System

## Overview
This application uses Supabase for authentication and user profile management. The system implements a custom trigger-based approach to automatically create and update user profiles when users sign up or log in via OAuth providers (primarily Google).

## Database Structure

### Tables
- **auth.users** - Managed by Supabase Auth, contains core user authentication data
- **public.profiles** - Custom table that stores user profile information linked to auth.users
- **public.auth_logs** - Logging table for debugging authentication and profile operations

### Profiles Table Structure
```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  first_name TEXT,
  last_name TEXT,
  avatar_url TEXT,
  email TEXT,
  redirect_after_login TEXT DEFAULT '/protected',
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
```

### Row Level Security (RLS) Policies
The profiles table has the following RLS policies:

1. **Public profiles are viewable by everyone**
   - Allows anyone to read profile data
   - `FOR SELECT USING (true)`

2. **Users can manage their own profile**
   - Allows authenticated users to update their own profile
   - `FOR ALL TO authenticated USING (auth.uid() = id) WITH CHECK (auth.uid() = id)`

3. **System can manage all profiles**
   - Allows the Postgres role to manage all profiles (needed for triggers)
   - `FOR ALL TO postgres USING (true) WITH CHECK (true)`

## Authentication Flow

1. User initiates login via Google OAuth provider
2. Supabase handles the OAuth flow and creates/updates a record in `auth.users`
3. The `user_auth_handler_trigger` executes `public.user_auth_handler()` function
4. The function extracts user data from the OAuth provider's metadata:
   - Name (parsed into first_name and last_name)
   - Email
   - Avatar URL
5. The function creates or updates a record in the `profiles` table
6. The user is redirected to the protected page after successful authentication

## Database Functions

### user_auth_handler()
This function is triggered after INSERT or UPDATE on auth.users. It:
- Extracts user metadata from the OAuth provider
- Parses the full name into first and last name
- Gets the avatar URL
- Creates or updates the user's profile
- Logs the operation in auth_logs

```sql
-- Primary function that handles user profile creation/updates
CREATE OR REPLACE FUNCTION public.user_auth_handler()
RETURNS TRIGGER AS $$
/* Full function implementation - see Database Migrations */
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### cleanup_old_auth_logs()
Utility function to remove old auth logs to prevent excessive table growth.

```sql
-- Removes auth logs older than 30 days
CREATE OR REPLACE FUNCTION public.cleanup_old_auth_logs()
RETURNS void AS $$
BEGIN
  DELETE FROM public.auth_logs
  WHERE created_at < (now() - INTERVAL '30 days');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## Logging System

The `auth_logs` table records authentication events for debugging purposes:

```sql
CREATE TABLE public.auth_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_type TEXT NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  details JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
```

Important event types:
- **user_created** - New user registered
- **user_updated** - Existing user updated
- **profile_created** - New profile created
- **profile_updated** - Existing profile updated

## Frontend Integration

The application uses Next.js with the Supabase SSR client for authentication. Key components:

1. **Login Form** (`src/components/login-form.tsx`)
   - Handles OAuth login via Google
   - Uses Supabase client to initiate the OAuth flow

2. **OAuth Callback Handler** (`src/app/auth/oauth/route.ts`)
   - Processes the OAuth callback
   - Exchanges code for session
   - Redirects to protected page upon success

3. **Middleware** (`src/middleware.ts`)
   - Protects routes based on authentication status
   - Updates session tokens
   - Redirects unauthenticated users to login

4. **Protected Pages** (`src/app/protected/page.tsx`)
   - Only accessible to authenticated users
   - Displays user information from the profiles table

## Troubleshooting

For authentication issues, check the `auth_logs` table:

```sql
-- View recent auth events
SELECT * FROM public.auth_logs ORDER BY created_at DESC LIMIT 20;

-- View auth logs for a specific user
SELECT * FROM public.auth_logs WHERE user_id = 'USER_UUID' ORDER BY created_at DESC;

-- View specific event types
SELECT * FROM public.auth_logs WHERE event_type = 'profile_created' ORDER BY created_at DESC;
```

## Future Enhancements

1. **Profile Extensions**
   - Additional profile fields can be added to the profiles table
   - Update the `user_auth_handler()` function to handle new fields

2. **Multiple OAuth Providers**
   - The current system works with any OAuth provider
   - Provider-specific parsing may need to be added for new providers

3. **Custom User Metadata**
   - Additional user metadata can be stored in the profiles table
   - Add UI components to allow users to update their profile information

## Database Migrations

Below are the key migrations that established this system:

### 1. Create Profiles Table
```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  first_name TEXT,
  last_name TEXT,
  avatar_url TEXT,
  email TEXT,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
```

### 2. User Auth Handler Function
```sql
CREATE OR REPLACE FUNCTION public.user_auth_handler()
RETURNS TRIGGER AS $$
DECLARE
  _raw_meta JSONB;
  _full_name TEXT;
  _first_name TEXT;
  _last_name TEXT;
  _avatar_url TEXT;
  _profile_exists BOOLEAN;
BEGIN
  -- Skip if user is marked as deleted
  IF NEW.deleted_at IS NOT NULL THEN
    RETURN NEW;
  END IF;

  -- Log the event with detailed metadata for debugging
  INSERT INTO public.auth_logs (event_type, user_id, details)
  VALUES (
    CASE 
      WHEN TG_OP = 'INSERT' THEN 'user_created'
      ELSE 'user_updated' 
    END,
    NEW.id, 
    jsonb_build_object(
      'email', NEW.email,
      'metadata', NEW.raw_user_meta_data,
      'operation', TG_OP,
      'timestamp', now()
    )
  );

  -- Extract metadata safely
  _raw_meta := COALESCE(NEW.raw_user_meta_data, '{}'::jsonb);
  
  -- Get name information
  _full_name := _raw_meta ->> 'full_name';
  IF _full_name IS NULL THEN
    _full_name := _raw_meta ->> 'name';
  END IF;
  
  -- Get avatar URL
  _avatar_url := _raw_meta ->> 'avatar_url';
  IF _avatar_url IS NULL THEN
    _avatar_url := _raw_meta ->> 'picture';
  END IF;

  -- Split full name
  IF _full_name IS NOT NULL AND LENGTH(_full_name) > 0 THEN
    _first_name := split_part(_full_name, ' ', 1);
    
    IF position(' ' in _full_name) > 0 THEN
      _last_name := substring(_full_name from position(' ' in _full_name) + 1);
    END IF;
  END IF;

  -- Check if profile exists
  SELECT EXISTS(SELECT 1 FROM profiles WHERE id = NEW.id)
  INTO _profile_exists;

  -- Handle profile creation/update
  IF _profile_exists THEN
    -- Update profile
    UPDATE profiles
    SET 
      first_name = COALESCE(_first_name, first_name),
      last_name = COALESCE(_last_name, last_name),
      email = NEW.email,
      avatar_url = CASE
        WHEN _avatar_url IS NOT NULL AND (avatar_url IS NULL OR _avatar_url <> avatar_url)
        THEN _avatar_url
        ELSE avatar_url
      END,
      updated_at = now()
    WHERE id = NEW.id;
    
    -- Log the update
    INSERT INTO public.auth_logs (event_type, user_id, details)
    VALUES ('profile_updated', NEW.id, jsonb_build_object(
      'email', NEW.email,
      'timestamp', now()
    ));
  ELSE
    -- Create new profile
    INSERT INTO profiles (
      id, 
      email, 
      first_name, 
      last_name, 
      avatar_url
    ) VALUES (
      NEW.id,
      NEW.email,
      _first_name,
      _last_name,
      _avatar_url
    );
    
    -- Log profile creation
    INSERT INTO public.auth_logs (event_type, user_id, details)
    VALUES ('profile_created', NEW.id, jsonb_build_object(
      'email', NEW.email,
      'timestamp', now()
    ));
  END IF;

  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  -- Log any errors
  INSERT INTO public.auth_logs (event_type, user_id, details)
  VALUES ('auth_error', COALESCE(NEW.id, NULL), jsonb_build_object(
    'error', SQLERRM,
    'email', COALESCE(NEW.email, 'unknown'),
    'timestamp', now()
  ));
  
  -- Continue even if there's an error
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger
CREATE TRIGGER user_auth_handler_trigger
AFTER INSERT OR UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.user_auth_handler();
```

### 3. Security Policies
```sql
-- Public read access
CREATE POLICY "Public profiles are viewable by everyone" 
ON profiles FOR SELECT USING (true);

-- User management of own profile
CREATE POLICY "Users can manage their own profile" 
ON profiles FOR ALL 
TO authenticated
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

-- System access for trigger functions
CREATE POLICY "System can manage all profiles" 
ON profiles FOR ALL 
TO postgres
USING (true)
WITH CHECK (true);
```

## Project Information

- **Project ID**: rpuscxehaowkqplamsse
- **Organization**: HPGAPP
- **Region**: ap-south-1
